= C++SIM User Manual
:numbered:

This is an object-oriented, discrete event simulation toolkit for C++. It was developed as a direct consequence of research conducted within the scope of the link:http://www.ncl.ac.uk/computing/research/publication/159390[Arjuna project from Newcastle University] in the 1980's. It has the following requirements:

* easy to learn and use: the interface to the simulation library should be easy to understand.
* correct abstraction: existing programmers should not find the simulation paradigm in conflict with the language. Simulation programmers used to other environments should find the transition to C++SIM straightforward.
* flexible and extensible: it should be relatively easy for anyone to add new functionality to the system, such as new distribution functions.
* efficiency: the system should be efficient and produce efficient simulation runs. Simulation packages which we have experience of tended to be extremely slow and consume large amounts of system resources.

These requirements were realised in the following design decisions:

- the discrete-event process based simulation facilities provided by SIMULA and its simulation classes and libraries have a considerable experience and user community which have found them to be successful for a wide variety of simulations. In later versions of the system additional simulation classes were added which provide extra functionality.

- inheritance was to be used throughout the design to even a greater extent than is already provided in SIMULA. This enables C++SIM to be more flexible and extensible, allowing new functionality to be added without affecting the overall system structure. For example, our I/O facilities, random number generators and probability distribution functions are entirely object-oriented, relying on inheritance to specialise their behaviour.

NOTE: It is not necessary for the reader to know anything about the SIMULA programming language or its simulation classes, but such knowledge would aid in the understanding of the concepts and classes presented within.

In the past we supported a range of different operating systems and thread packages. However, in recent years it has become hard for the team to test this wide a combination and therefore currently we only support Linux, pthreads and gcc. If you have any problems, questions, suggestions etc. then consider raising an issue on the link:https://github.com/nmcl/C--SIM/issues[github page] or even fork C++SIM and raise a pull request.

== Introduction

This manual is not intended as a tutorial on the concepts of simulation in general, but rather how to write simulations in the C++SIM system. However, in order to be able to do this certain key simulation concepts will be briefly described. The interested reader is referred to link:http://dl.acm.org/citation.cfm?id=539335[this book] for detailed descriptions of these concepts and for further discussions on simulation modelling.

=== Simulation Models

To model a system is to replace it by something which is:

- simpler and/or easier to study. 

- equivalent to the original in all important respects. 

Therefore, before constructing the actual simulation, it is first necessary to abstract from the real system those components and their interactions that are considered important for the actual model. Building a simulation system model involves making certain simplifying assumptions to aid in the actual implementation and study of the simulation (without such simplifications the model would be as complex as the system it is meant to be simulating). However, the accuracy of the results obtained from the simulation depend upon how valid the initial assumptions are. For example, when considering the trajectory of a projectile through the atmosphere, the friction due to the air molecules is usually ignored. This assumption is valid only within certain boundaries: if the size of the projectile is on the same scale as the air molecules and its speed is sufficiently small then friction plays a significant role in its movement.

Thus, the first step towards building a simulation model of a system is to determine exactly what are the important features which are to be measured, and what characteristics of the system have an affect on them. Any boundary conditions for the simulation (e.g., size of projectile) should be considered at the same time in order to simplify this procedure. Building a final model can often take several phases, where results from the initial model are compared with those obtained from the real system to determine their accuracy. Any discrepancies are taken into account by possibly adding new components to the simulation until, within certain error boundaries, the simulation results match those from the real system.

=== Terminology

The system components chosen for the simulation are termed simulation entities. Associated with each _entity_ in the simulation are zero or more _attributes_ that describe the state of the entity and which may vary during the course of the simulation. The interaction of entities and the changes they cause in the system state are termed _events_.

The collection of these component attributes at any given time _t_ defines the system state at _t_. In general, the system state can take any of a variety of values, and a given simulation run results in one realisation of a set of these values (the _operation path_) over the _observation period_.

=== Categories of simulation models

There are three categories of simulation model, described by the way in which the system state changes as a function of time:

- _Continuous time_: is one whose state varies continuously with time; such systems are usually described by sets of differential equations. 

- _Discrete time_: the system is considered only at selected moments in time (the observation points). These moments are typically evenly spaced. Some economics models are examples of this, where economics data becomes available at fixed intervals. Changes in state are noticed only at observation points. By choosing a suitably small interval between observation points, a continuous time simulation can be approximated by a discrete time simulation. 

- _Continuous time-discrete event_: the time parameter is (conceptually) continuous and the observation period is a real interval, usually starting at zero for simplicity. The operation path is completely determined by the sequence of event times (which need not be evenly spaced and can be of arbitrary increments) and by the discrete changes in the system state which take place at these times (i.e., the interactions of the events). In between consecutive event times the system state may vary continuously. Although it is possible to model the passage of real time by suitable event timing, this is not necessary for a discrete event system: the simulation model can advance its own internal time directly from one discrete event to another, taking any appropriate action to advance the state accordingly. 

It is this latter category of simulation modelling that C++SIM supports. Examples of discrete-event simulations are most queuing problems: entities (e.g., customers in a bank) arrive according to a given distribution and change the system state instantaneously (e.g., the number of customers in the queue). The operation paths for this system are step functions: they jump up (or down) by one when a customer joins (or leaves) the queue.

=== Event scheduling

Given that a simulation consists of a series of interacting events (the operation path), a simulator can be defined as that program devoted to the generation of operation paths. The simulator allows the creation of events and controls their interactions according to a set of rules, using an internal “clock” to keep track of the passage of (simulation) time.

It maintains an _event list_, which indicates which events are to be scheduled for execution at specific simulation times. Events are executed according to their simulation times. There are two approaches to the way in which a simulator can schedule events to produce an operation path:

- _event-oriented_: there is a procedure associated with each type of event in the system: it performs the action required to handle that type of event and it is invoked every time such an event occurs. In an event-oriented approach, an operation path is obtained by taking a global view of everything that happens in the system; the manipulation of events is explicit. 

- _process-oriented_: an operation path is obtained by the interacting of a number of processes running in parallel. The management of events is implicit in the management of the processes. The simulation system provides primitives for placing processes at particular points on the event list, removing and re-scheduling them. 
The C++SIM User’s Manuals

The process-oriented approach best fits with the object-oriented paradigm which we want to present to the programmer of C++SIM. As in SIMULA, simulation processes then become active objects which interact with each other through message passing and the simulation primitives. Refinements of these objects can then be obtained by inheriting from them and redefining the appropriate methods.

== The C++ Abstract Threads Interface

In keeping with the C++ programming model classes obtain the _thread_ characteristic, necessary to convey the notion of "activity" within the simulation environment, by inheriting an appropriate base class (in simulation terms they become _processes_). There is a minimum functionality which we require from any threads library that may be used for the simulation package, and to enforce this all classes which provide the abstraction of threads must be derived from the Thread base class. This base class provides the definitions of the operations which must _at least_ be provided by the deriving class: we use pure virtual functions to enforce this rule.

----
class Thread
{
public:
    virtual void Suspend();
    virtual void Resume();
    
    virtual void Body() = 0;  // the main part of the thread code to execute
    
    virtual long Current_Thread() const;
    virtual long Identity() const;
    static Thread* Self();
    
    static void Exit (int = 0);
    static void mainResume ();
    
    // Initialize must be called exactly once at the start of the program

    static void Initialize ();
};
----

The Suspend and Resume methods will give thread package specific ways of suspending and resuming execution of a thread respectively.

Body represents the controlling code for each object, i.e., the scope within which the controlling thread will execute.

Current_Thread must be defined by the derived class as it returns the identity of the currently executing thread, which is specific to the thread package used.

The implementations of the operations Identity and Self are provided by the base class because some threads packages do not provide similar functionality: Identity returns the unique identity of the thread associated with the given objects, and Self returns the currently executing thread. Because Self is a _static_ member function it can be invoked without creating an instance of the Thread class, i.e., using Thread::Self().

=== Specific Thread Class Implementations

Over the years we have supported a wide variety of thread packages, ranging from those available in various Unix implementations such as Solaris, through Posix compliant thread packages and to Windows threads. However, currently we can only test on Linux so that is the only implementation we support.

== Basic simulation classes

This section describes the core elements of the simulation system. It is not intended as a tutorial on C++, and basic knowledge of the language is assumed. Note, all of the classes described in this section can be found in the org.javasim package.

=== The simulation scheduler

The previous section described the event list and how simulation entities (processes) are executed according to their position on the event list (i.e., with increasing simulation time). In C++SIM, as in SIMULA, simulation processes are managed by a _scheduler_ and are placed on a _scheduler queue_ (the event list). Processes are executed in pseudo-parallel, i.e., only one process executes at any instance of real time, but many processes may execute concurrently at any instance of simulation time. The simulation clock is only advanced when all processes have been executed for the current instance of simulation time.

Inactive processes are placed on to the scheduler queue, and when the current active process yields control to the scheduler (either because it has finished or been placed back onto the scheduler queue), the scheduler removes the process at the head of the queue and re-activates it. (In SIMULA the currently active process is not removed from the head of the queue.) When the scheduler queue is empty, i.e., there are no further processes left to execute, the scheduler terminates the simulation.

image::images/queues.jpg[simulation queues]

Figure 1: Scheduler-Process Interaction

As Figure 1 shows, the scheduler co-ordinates the entire simulation run, effectively monitoring the active and passive processes to enable it to determine when, and which, process to activate next. A simulation application cannot affect the scheduler directly, but can do so only indirectly through modifications of the scheduler queue.

NOTE: the scheduler queue can be structured in a variety of ways, including a linear list or a tree. The implementation of the queue can depend upon the type of simulation being conducted. For example, a simulation which involves many (concurrent) processes would suffer from using a linear ordered queue which would typically have insertion and removal routines with overheads proportional to the number of entries in the queue. However, a linear list may work best for a low number of simulation processes. C++SIM comes with a suite of scheduler queue implementations which can be chosen when the system is built.

==== Scheduler and Simulation classes

The simulation scheduler is an instance of the Scheduler class. It is the responsibility of the application programmer to ensure that only a single instance of this class is created.

NOTE: In recent versions of C++SIM the Simulation class has taken on some of the functionality previously incorporated within the Scheduler class.

----
class Scheduler
{
    double CurrentTime () const;

    void reset () const;  // reset the simulation time

    static Scheduler& scheduler ();
    static void       terminate ();

    void Suspend ();
    void Resume ();

    static Boolean simulationStarted ();
}
----

The scheduler maintains the simulation clock, and the current value of this clock is obtained by invoking the CurrentTime() method.

To enable multiple simulation runs to occur within a single application, it is possible to reset it and the simulation clock by calling the reset() method of the Scheduler class. This causes the simulation to remove all processes (simulation objects) currently registered on the scheduler queue and to invoke a class specific method on each of them which resets their states (detailed in the next section). Once this is finished the simulation is ready for an additional run. It must then perform any work necessary to put itself back in a state ready for restarting the simulation, and should then suspend itself again before the simulation can be restarted (typically by calling cancel.)

=== Simulation processes

As was described in the previous sections, the package supports the process-oriented approach to simulation, where each simulation entity can be considered a separate process. Therefore in the entities within a simulation are represented by _process objects_. These are C++ objects which have an independent thread of control associated with them at creation time, allowing them to convey the notion of activity necessary for participating in the simulation.

In keeping with the object-oriented paradigm, and to make development of process objects simpler, classes inherit the process functionality from the appropriate base class (SimulationProcess). This class defines all of the necessary operations for the simulation system to control the simulation entities within it, and for them to interact with it and each other.

At any point in simulation time, a process can be in one (and only one) of the following states:

- _active_: the process has been removed from the head of the scheduler queue and its actions are being executed. 

- _suspended_: the process is on the scheduler queue, scheduled to become active at a specified simulation time. 

- _passive_: the process is not on the scheduler queue. Unless another process brings it back on to the queue it will not execute any further actions.

- _terminated_: the process is not on the scheduler queue and has no further actions to execute. Once a process has been terminated it cannot be made to execute further in the same simulation run. 

A process which is either active or suspended is said to be _scheduled_.

==== The Simulation Process class

The Process class definition is shown below. Before considering how to build an example class derived from Process we shall discuss the methods which it provides.

Because the constructors are protected, it is not possible to create an instance of the Process class, i.e., classes must be derived from this. Processes are threaded objects, and typically each thread package schedules execution of threads according to a priority. By default, all processes in C++SIM are created with the same priority.

----
class Process : public Thread
{
    /* The following two methods return the current simulation time */

    static double CurrentTime ();       // C++SIM version
    double Time () const;	        // SIMULA version

    double evtime () const;  // time at which process is scheduled to be active

    /*
     * The following method returns a reference to the next process to be run
     * by the scheduler *if* this object is active or scheduled to run.
     */

    const Process* next_ev () const;

    /*
     * There are five ways to activate a process:
     *   1) at the current simulation time
     *   2) before another process,
     *   3) after another process,
     *   4) at a specified (simulated) time, or
     *   5) after a specified (simulated) delay
     */

    void Activate ();
    void ActivateBefore (Process &);
    void ActivateAfter  (Process &);

    void ActivateAt     (double AtTime = CurrentTime(), Boolean prior = FALSE);
    void ActivateDelay  (double AtTime = CurrentTime(), Boolean prior = FALSE);

    /*
     * Similarly, there are five ways to reactivate
     * Note that if a process is already scheduled, the reactivate
     * will simply re-schedule the process.
     */

    void ReActivate ();
    void ReActivateBefore (Process &);
    void ReActivateAfter  (Process &);

    void ReActivateAt     (double AtTime = CurrentTime(), Boolean prior = FALSE);
    void ReActivateDelay  (double AtTime = CurrentTime(), Boolean prior = FALSE);

    void    Cancel ();	         // cancels next burst of activity, process becomes idle
    Boolean idle () const;	 // TRUE if process is not awake or not scheduled to wake up

    Boolean passivated () const; // returns whether or not the object has been passivated
    Boolean terminated () const; // returns whether or not the object has been terminated

    virtual void terminate ();   // terminate the process - no going back!

    static const Process* current ();  // returns current process

    /*
     * The pure virtual function, Body, defines the code that executes in
     * the process.
     */

    virtual void Body () = 0;

    /*
     * This method is called whenever a simulation is reset. Default does
     * nothing.
     */

    virtual void reset  ();

    static Process* Current;

protected:
    Process ();
    Process (unsigned long stackSize);

    void Hold (double t);     // suspend current process for simulated time t
    void Passivate ();	      // suspend current process (i.e., make idle)

    void set_evtime (double); // set wakeuptime (used by Scheduler)

    // remove from scheduler queue and prepare for passivation
    void unschedule ();
}
----

There are five ways to activate a currently passive process, which results in it being brought to the correct position in the scheduler queue corresponding to its associated simulation time. If this is the head of the queue then it will become the active process.

- Activate(): this activates the process at the current simulation time. 

- ActivateBefore(Process& proc): this positions the process in the scheduler queue before proc, and gives it the same simulation time. If proc is not present then an error message will be displayed. 

- ActivateAfter(Process& proc): this positions the process in the scheduler queue after proc, and gives it the same simulation time. If proc is not present then an error message will be displayed. 

- ActivateAt(double AtTime = CurrentTime(), Boolean prior = FALSE): the process is inserted into the scheduler queue at the position corresponding to the simulation time specified by AtTime. The default for this time is the current simulation time. The prior parameter is used to determine whether this process should be inserted before or after any processes with the same simulation time which may already be present in the queue. The default is FALSE. 

- ActivateDelay(double AtTime = CurrentTime(), Boolean prior = FALSE): the process is activated after a specified delay (AtTime). The process is inserted into the queue with the new simulation time, and the prior parameter is used to determine its ordering with respect to other processes in the queue with the same time. The default is FALSE. 

There are correspondingly five ReActivate methods, which work on either passive or scheduled processes. These will not be described in detail as they have similar signatures to their Activate counterparts and work in the same way.

- Hold(double period) schedules the currently active process for re-activation after the simulated delay of period time. If this is invoked by the object (e.g., through a publicly available method) when it is not the current active process then it does nothing.

- evtime() returns the time at which the process is scheduled for activation.

- next_ev() returns a reference to the next process to be scheduled for execution. If the queue is empty then null is returned.

The static variable Current returns a reference to the currently active process.

The current simulation time can be obtained by using either the CurrentTime() or Time() methods. The former method is static and as such can be invoked without an instance of the SimulationProcess class.

Cancel() removes the process from the scheduler queue or suspends it if it is the currently active process. In either case, the process is set to the passive state. Passivate() functions similarly but only works on the currently active process, i.e., if it is invoked by the object (e.g., through a publicly available method) when it is not the current active process then it does nothing.

terminate() removes the process from the scheduler queue or it is suspended if it is currently active. The process is then set to the terminated state, and can take no further part in this simulation run.

idle() returns FALSE if the process is either active or scheduled to become active. Otherwise TRUE is returned.

passivated() and terminated() indicate whether the process is in the passive or terminated state, respectively.

Because Process extends the Thread class it is necessary for the simulation class to provide an implementation of the Body method which will do the actual work for the process. If this method ever returns then the thread is destroyed. However, in order for C++SIM to detect the termination of the thread, the terminate() method _must_ be used instead.

===== Resetting

Resetting a simulation involves resetting all of the objects involved in it which will be required for subsequent runs. To reset a simulation, the
reset method of the simulation scheduler must be invoked. This then calls the corresponding reset methods for all of the process objects which are currently on the simulation queue. However, there is a difference between resetting the state of a process and resetting its associated thread. The thread can only be reset when it is next activated. Because a reset can potentially occur at any point, it is necessary for an active process to be able to determine whether it was reset while it was inactive, and take appropriate action.

C++SIM provides macros for this (located in the reset.h header file), both based upon the CSP notion of guarded commands. Operations are performed and  a reset condition can be checked before the process acts upon the results. If a reset occurs, the reset method for the Process should be written so that it sets this condition flag to an appropriate state.

RESET_POINT is used for specifying the reset position within a method where the flow of control will be returned to upon detecting a reset.

MONITOR_RESET(x,y,z) executes statement x and upon completion statements y and z are compared. If they are equal, then the control flow is returned to the RESET_POINT.

CHECK_RESET(y,z) compares statements.

===== Example

To illustrate how a simulation process could be implemented from the Process class we shall consider the example of a queue of customers arriving at a bank. For this example, this involves three classes:

- Customer: instances of this class represent the customers in the queue. 

- Queue: the instance of this class (queue) is the queue into which customers are places. 

- Arrivals: this is the process which creates new customers for insertion in queue. 

The implementations of the Customer and Queue classes are not important to this example. The implementation of the Arrivals class could be:

----
class Arrivals : public Process
{
public:
    Arrivals (double);
    virtual ~Arrivals ();

    virtual void Body ();

private:
    ExponentialStream* InterArrivalTime;
};

void Arrivals::Body ()
{
    for (;;)
    {
	    double arrivalTime = (*InterArrivalTime)();
	
	    Hold(arrivalTime);
	    Job* work = new Job();
    }
}
----

=== Priority Threads

In the simulation there are two "priority" threads which cannot be derived from the Process base class and therefore must be activated and deactivated separately:

- the simulation scheduler: this must be activated using the Resume method of the thread base class from which it is derived (e.g., LWP_Thread);

- the thread associated with main. To allow other threads to run it is necessary to suspend this thread as it has the highest priority in the system. By making a call to the Initialize method of the Thread class within the main body of the simulation code this thread is added to the thread queue maintained by the Thread class. This then allows the Suspend method to be invoked on the thread later when it is required to become inactive (using the Thread::Self()->Suspend() operation).

== Distribution Functions

Many of the aspects of the real world which a simulation attempts to model have properties which correspond to various distribution functions, e.g., inter-arrival rates of customers at a bank queue. Therefore, simulation studies require sources of random numbers. Ideally these sources should produce an endless stream of such numbers, but to do so either requires specialised hardware or the ability to store an infinite (large) table of such numbers generated in advance.

Without such aids, which are either impractical or not generally available, the alternative is to use numerical algorithms. No deterministic algorithm can produce a sequence of numbers that would have all of the properties of a truly random sequence (see link:http://www.amazon.com/Art-Computer-Programming-Volume-Seminumerical/dp/0201896842[Knuth, Volume 2.]) However, for all practical purposes it is only necessary that the numbers produced appear random, i.e., pass certain statistical tests for randomness. Although these generators produce pseudo-random numbers, we continue to call the random number generators.

The starting point for generating arbitrary distribution functions is to produce a standard uniform distribution. As we shall see, all other distributions can be produced based upon this. (Interested readers are referred to link:http://dl.acm.org/citation.cfm?id=539335[this] for a more complete treatment of this topic). All of the distribution functions in C++SIM rely upon inheritance to specialise the behaviour obtained from the uniform distribution class. These classes can be found in the org.javasim.streams package.

=== RandomStream

The actual uniform distribution class is called RandomStream. This returns a series of random numbers uniformly distributed between 0 and 1. We experimented with several random number generators before settling on a shuffle of a multiplicative generator with a linear congruential generator, which provides a reasonably uniform stream of pseudo-random numbers.

----
class RandomStream
{
public:
    virtual double operator() () = 0;
    double Error ();	// returns a chi-square error measure on the uniform
			// distribution function
    
protected:
    RandomStream (long MGSeed=772531L, long LCGSeed=1878892440L);
    
    double Uniform ();
}
----

The multiplicative generator uses the following algorithm:

Y[i+1] = Y[i] * 5^5^ mod 2^26^

, where the period is 2^24^, and the initial seed must be odd (Thanks to Professor I. Mitrani for his help in developing this.)

The Uniform() method uses the linear congruential generator (seed is LCGSeed, with the default value of 1878892440L) based on the algorithm in link:http://algs4.cs.princeton.edu/home/[this text], and the results of this are shuffled with the multiplicative generator (seed is MGSeed, with a default value of 772531L) as suggested by link:http://www.amazon.com/Art-Computer-Programming-Volume-Seminumerical/dp/0201896842[Maclaren and Marsaglia], to obtain a sufficiently uniform random distribution, which is then returned.

The Error() method returns a chi-square error measure on the uniform distribution function.

By pure virtual operator() must be provided by derived classes, and is used to obtain a uniform means of accessing random numbers.

The  RandomStream class  returns  a  large  sequence  of  random  numbers,  whose  period  is 2^24^. However, unless the seeds are modified when each random distribution class is created, the starting position in this sequence will always be the same, i.e., the same sequence of numbers will be obtained. To prevent this, each class derived from RandomStream has an additional parameter for one of its constructors which indicates the offset in this sequence from which to begin sampling.

=== UniformStream

The UniformStream class inherits from RandomStream and returns random numbers uniformly distributed over a range specified when the instance is created.

----
class UniformStream : public RandomStream
{
public:
    UniformStream (double lo, double hi, int StreamSelect=0,
		   long MGSeed=772531L, long LCGSeed=1878892440L);
    virtual double operator() ();
}
----

The range covers the interval specified by lo and hi. StreamSelect indicates the offset in the random number sequence to begin sampling, and MGSeed and LCGSeed can be used to modify the seed values used by the RandomStream class.

=== ExponentialStream

The ExponentialStream class returns an exponentially distributed stream of random numbers with mean value specified by mean.

----
class ExponentialStream : public RandomStream
{
public:
    ExponentialStream (double Mean, int StreamSelect=0,
		       long MGSeed=772531L, long LCGSeed=1878892440L);
    virtual double operator() ();
}
----

StreamSelect indicates the offset in the random number sequence to begin sampling, and MGSeed and LCGSeed can be used to modify the seed values used by the RandomStream class.

=== ErlangStream

ErlangStream returns an erlang distribution with mean mean and standard deviation sd.

----
class ErlangStream : public RandomStream
{
public:
    ErlangStream (double Mean, double StandardDeviation, int StreamSelect=0,
		  long MGSeed=772531L, long LCGSeed=1878892440L);
    virtual double operator() ();
}
----

StreamSelect indicates the offset in the random number sequence to begin sampling, and MGSeed and LCGSeed can be used to modify the seed values used by the RandomStream class.

=== HyperExponentialStream

The HyperExponential class returns a hyper-exponential distribution of random numbers, with mean mean and standard deviation sd.

----
class HyperExponentialStream : public RandomStream
{
public:
    HyperExponentialStream (double Mean, double StandardDeviation,
			    int StreamSelect=0,
			    long MGSeed=772531L,long LCGSeed=1878892440L);
    virtual double operator() ();
}
----

StreamSelect indicates the offset in the random number sequence to begin sampling, and MGSeed and LCGSeed can be used to modify the seed values used by the RandomStream class.

=== NormalStream

NormalStream returns a normal distribution of random numbers, with mean mean and standard deviation sd. operator() uses the polar method due to link:http://www.amazon.com/Art-Computer-Programming-Volume-Seminumerical/dp/0201896842[Box, Muller, and Marsaglia.]

----
class NormalStream : public RandomStream
{
public:
    NormalStream (double Mean, double StandardDeviation, int StreamSelect=0,
		  long MGSeed=772531L,long LCGSeed=1878892440L);
    virtual double operator() ();
}
----

StreamSelect indicates the offset in the random number sequence to begin sampling, and MGSeed and LCGSeed can be used to modify the seed values used by the RandomStream class.

=== Draw

The Draw class is the exception to the inheritance rule, instead using RandomStream through delegation (for historical reasons). This returns true with the probability prob, and false otherwise.

----
class Draw
{
public:
    Draw (double p, int StreamSelect=0,
	  long MGSeed=772531L, long LCGSeed=1878892440L);
    virtual Boolean operator() ();
}
----

StreamSelect indicates the offset in the random number sequence to begin sampling, and MGSeed and LCGSeed can be used to modify the seed values used by the RandomStream class.

=== Example

In this example we will take a NormalStream instance obtain values from it which are then inserted in a Histogram so that we can then print out the contents and associated data. As we have already seen that NormalStream derives from RandomStream along with the other stream types, this example can be easily changed to use something else, such as the ExponentialStream.

----
NormalStream str(100.0, 2.0);
Histogram* hist = new Histogram(10);

for (int i = 0; i < 1000; i++)
{
  hist->setValue(str());
}

cout << "NormalStream error: " << str.Error() << endl;

cout << *hist << endl;
----

If you were to execute this code then the output would be similar to the following:

----
NormalStream error: -0.1976
Maximum number of buckets 10
Merge choice is MEAN
Bucket : < 97.287, 2 >
Bucket : < 97.8288, 1 >
Bucket : < 98.4152, 441 >
Bucket : < 98.8398, 1 >
Bucket : < 99.3424, 1 >
Bucket : < 100.672, 1 >
Bucket : < 101.221, 1 >
Bucket : < 101.225, 545 >
Bucket : < 102.365, 5 >
Bucket : < 104.292, 2 >

Variance          : 3.68377
Standard Deviation: 1.91932
Number of samples : 1000
Minimum           : 1.17549e-38
Maximum           : 3.40282e+38
Sum               : 99981.7
Mean              : 99.9817
----

We will learn more about the Histogram class later in this document.

== Advanced Simulation Classes

Simulations formed by the interaction of objects derived from Process can be considered _causal_ (synchronous) in nature: events occur at specific times and form a well defined order. However, it is sometimes necessary to simulate asynchronous real world events, e.g., processor interrupts. To do this requires finer-grained control of the scheduling of simulation processes than it provided by the scheduler; the scheduler simply activates according to simulation time, whereas asynchronous events may have different activation rules, e.g., activate when another process is terminated.

The Entity class and others to be described in the following sections gives this required level of control to the user, extending the types of simulation which are possible with C++SIM. Asynchronous simulation processes are derived from Entity, but the implementation enables these asynchronous process to execute in the same simulation as Process objects. However, because these processes are suspended and resumed outside of the control of the scheduler, it is possible for deadlock situations to occur. Therefore, some care must be taken when using these classes.

In addition to the active, suspended, passive and terminated states which a simulation process can be in, asynchronous objects can also be in the following states:

- _waiting_: the process is suspended waiting for a specific event to occur (e.g., a process to be terminated). The waiting process is _not_ placed on the scheduler queue.

- _interrupted_: the process, which was in the waiting state, has been interrupted from this before the condition it was awaiting occurred. 

The conditions on which a process can wait, and can thus be interrupted from, are:

- _time_: a process can attempt to wait for a specified period of simulation time. 

- _process termination_: a process can wait for the termination of another SimultionEntity process before continuing execution. 

- _semaphore_: critical regions of a simulation can be protected by semaphores, where only a single Entity process can acquire the semaphore; other processes are suspended until the semaphore is released. 

- _user specific_: it is possible for other asynchronous conditions to occur which are not covered above.

The classes to be described in this chapter can be found in the Event source.

=== Asynchronous entities

----
class Entity : public Process
{
public:
    virtual ~Entity ();

    // Interrupt process which in wait state.

    Boolean Interrupt (Entity&, Boolean = TRUE);
    void    trigger ();

    Boolean isWaiting () const;

    virtual void terminate ();       // terminate the process - no going back!

    /*
     * The pure virtual function, Body, defines the code that executes
     * in the process.
     */

    virtual void Body () = 0;

protected:
    Entity ();
    Entity (unsigned long stackSize);

    Boolean Wait (double);                  // wait for set period of time
    Boolean WaitFor (Entity&, Boolean = FALSE);// wait for process to terminate
    Boolean WaitForTrigger (TriggerQueue&);
    void WaitForSemaphore (Semaphore&);
 }
----

Because Entity is derived from Process, all of the usual simulation methods are available, and can be used in conjunction with those provided by the derived class.

Interrupt(Entity& toInterrupt, Boolean immediate) interrupts the asynchronous process toInterrupt, which _must_ not be *terminated* and _must_ be in the *waiting* state. toInterrupt becomes the next active process (i.e., it is moved to the head of the scheduler queue). If immediate is true then the current process is suspended immediately; it is scheduled for reactivation at the current simulation time. Otherwise, the current process continues to execute and can be suspended later in an application specific way.

Because it is now possible for one process to wait for another to terminate the terminate() method must differ from that provided by Process. Before the terminating process ends it moves the waiting process to the head of the scheduler queue, and then calls Process.terminate(). Currently only a single process can wait on this termination condition, but this may change in future versions.

Wait(double t) is similar to Hold(double t), with the exception that the process is moved into the *waiting* state as well as being placed on the scheduler queue. It is therefore possible to interrupt this process before the wait period has elapsed. true is returned if the process was interrupted, otherwise false is returned.

WaitFor(Entity& controller, boolean reAct) suspends the current process until controller has terminated. The process is placed in the *waiting* state. If reAct is true then controller is moved to the head of the scheduler queue to become the next activate process, otherwise (the default behaviour) the application will have to activate controller. If the waiting process is interrupted then the method returns true, otherwise false. The controller and the current process must be different, i.e., it is not possible for a process to wait for itself.

_Trigger queues_ are lists maintained by the simulation system of process waiting for specific events to occur, which are outside the scope of those described above. These will be described in the next section. WaitForTrigger(TriggerQueue& queue) places the current process on the trigger queue and passivates it. As with the previous methods, the return value indicates whether the process was interrupted, or triggered.

In addition to trigger queues, process can wait on semaphores, allowing the creation of monitor regions, for example. WaitForSemaphore(Semaphore& sem) causes the current process to attempt to exclusively acquire the semaphore. If this is not possible then the process is suspended. Currently, a process which is waiting on a semaphore cannot be interrupted, and is not placed into the *waiting* state. As such, when this method returns the semaphore has been acquired.

=== Trigger queues

Processes waiting for the same application controlled event can be grouped together into a TriggerQueue, as described in the previous section. When this event occurs the application can use one of the two trigger methods to activate the queue members. This involves placing the process(es) onto the head of the scheduler queue.

----
class TriggerQueue
{
public:
    TriggerQueue ();
    virtual ~TriggerQueue ();

    Boolean triggerAll ();
    Boolean triggerFirst (Boolean = TRUE);

protected:
    void insert (Entity*);
    Entity* remove ();
}
----

- triggerAll(): triggers all of the members on the queue. 

- triggerFirst(Boolean setTrigger): triggers only the head of the queue. If the parameter is TRUE (the default behaviour) then the trigger() method of the Entity object is also invoked. 

If the queue is not empty when it is garbage collected by the virtual machine then all remaining queue members will be triggered, and placed back onto the scheduler queue.

=== Semaphores

Application code can be protected from simulation processes through semaphores, which are instances of the Semaphore class.

----
class Semaphore
{
public:
    enum Outcome { DONE, NOTDONE, WOULD_BLOCK };
	
    Semaphore ();
    Semaphore (long number, Boolean ceiling = FALSE); // number of resources available
    virtual ~Semaphore ();

    virtual Semaphore::Outcome Get (Entity*);
    virtual Semaphore::Outcome Release ();
    
    /*
     * Try to get the semaphore, but return if this would block
     * the caller.
     */
    
    virtual Semaphore::Outcome TryGet (Entity*);

    long NumberWaiting () const;
}
----

A semaphore can be used to restrict the number of processes which can use shared resources. The number of shared resources available must be presented to the Semaphore when it is created. By default, a Semaphore will assume that there is only a single resource, in which case a semaphore is exclusively acquired by a simulation process. However, it is possible to create a Semaphore with different resource counts.

A Semaphore can exist in one of two states:

- _available_: the semaphore is available to be acquired. 

- _unavailable_: a process (or number of processes) currently has the semaphore. If another process attempts to acquire the semaphore then it is automatically suspended until the semaphore is *available*, i.e., until a resource has been freed. 

To be able to manipulate semaphores a process must be derived from the Entity class. To obtain the semaphore, the Get(Entity* toWait) method should be used, where ToWait is the calling process. If the semaphore is *unavailable* then the process referenced by ToWait is suspended. If the semaphore is successfully acquired, then DONE is returned, otherwise NOTDONE.

If the process wishes to attempt to acquire the semaphore but does not want to block in the situation where the semaphore is currently unavailable, then it can use the TryGet method, which takes the same parameter as Get. However, unlike Get, TryGet will return WOULD_BLOCK in the case where the caller would normally block if it had called Get, i.e., the semaphore is currently in use. If the semaphore is not being used, then TryGet will acquire it for the caller. Errors will result in NOT_DONE being returned.

When the semaphore is no longer required Release() should be called by the process which currently has it. Successful release of the semaphore results in DONE being returned, otherwise NOTDONE is returned.

NumberWaiting() returns the number of processes currently suspended waiting for the semaphore.

If the semaphore is garbage collected with processes waiting for it then an error message is displayed. No further action is attempted on behalf of these waiting processes.

=== Example

If you check the _interrupt_ example in the source distribution you will find it uses the SimulationEntity to model asynchronous behaviour. For instance, the Processor class, some of which is shown below:

----
void Processor::Body ()
{
    Job* j = (Job*) 0;

    for (;;)
    {
	if (Wait((*sTime)()))
	{
	    if (!JobQ.IsEmpty())
	    {
	        j = JobQ.Dequeue();
		delete j;
		ProcessedJobs++;
	    }
	}
	else
	{
	    if (SignalQ.IsEmpty())
	        cerr << "Error - signal caught, but no message given!" << endl;
	    else
	    {
	        j = SignalQ.Dequeue();
		delete j;
		SignalledJobs++;
	    }
	}

	if (SignalledJobs == 2)
	    terminate();
    }
}
----

As can be seen, the Processor uses timedWait to hold for a specified period of time but this can be interrupted by an event, in this case that a message has been delivered.

Semaphores are used within the simulation system. However, they can also be used by the application developer. For instance, the following example creates a Semaphore which protected 2 resources that are being accessed by 3 SimulationEntities:

NOTE: Java version. Needs to be rewritten in C++.

----
Semaphore sem(2);
DummyEntity e1(10);
DummyEntity e2(20);
DummyEntity e3(30);

if (sem.NumberWaiting() != 0)
{
  cerr << "First sem.NumberWaiting() " << sem.NumberWaiting() << endl;
  return -1;
}

Semaphore::Outcome result = sem.Get(&e1);

if (result != Semaphore::DONE)
{
  cerr << "First Get " << result << endl;
  return -1;
}

result = sem.Get(&e2);

if (result != Semaphore::DONE)
{
  cerr << "Second Get " << result << endl;
  return -1;
}
  
result = sem.TryGet(&e3);

if (result != Semaphore::WOULD_BLOCK)
{
  cerr << "TryGet " << result << endl;
  return -1;
}

result = sem.Get(&e3);

if (result != Semaphore::DONE)
{
  cerr << "Third Get " << result << endl;
  return -1;
}

if (sem.NumberWaiting() != 1)
{
  cerr << "Second sem.NumberWaiting() " << sem.NumberWaiting() << endl;
  return -1;
}
----

As can be seen, the number of resources is passed to the Semaphore when it is created. We then create 3 SimulationEntities. At this stage there are no entities waiting (blocked waiting) on the Semaphore (numberWaiting returns 0). The first two entities gain access to the resources by calling Semaphore.get() before they would access or manipulate the resource(s). In this example we know that because no entity has yet released its access to the resource (e.g., lock on the resource), the next entity to try to acquire access via Semaphore.get() will block. To verify this we can use Semaphore.tryGet(), which in this case returns Outcome.WOULD_BLOCK to indicate this fact. Regardless, we then try to acquire access to the resource(s) and that entity is then blocked. This is verified by checking the number of entities waiting on the semaphore being released, i.e., numberWaiting() returns 1 in this case.

== Statistical classes

The purpose of a simulation typically involves the gathering of relevant statistical information, e.g., the average length of time spent in a queue. C++SIM provides a number of different classes for gathering such information. These classes can be found in the org.javasim.stats package.

=== Mean

This is the basic class from which others are derived, gathering statistical information on the samples provided to it.

----
class Mean
{
public:
    Mean ();
    virtual ~Mean ();

    virtual void setValue (double);
    virtual void operator+= (double);

    virtual void reset ();

    unsigned int numberOfSamples () const;

    double min () const;
    double max () const;
    double sum () const;
    double mean () const;

    virtual ostream& print (ostream&) const;
    
    virtual Boolean saveState (const char*) const;
    virtual Boolean saveState (ofstream&) const;
    
    virtual Boolean restoreState (const char*);
    virtual Boolean restoreState (ifstream&);
}
----

New values can be supplied to the instance of the Mean class using the setValue(double) method. The number of samples which have been give can be obtained from numberOfSamples().

The maximum and minimum of the samples supplied can be obtained from the max() and min() methods, respectively.

sum() returns the summation of all of the samples:

image::images/maths1.jpg[]

mean() returns the mean value:

image::images/maths2.jpg[]

An instance of Mean can be reset between samples using the reset() method.

If the state of a Mean object is required to be saved between simulation runs then it can be made persistent by using either of the saveState methods. The first instance saves the state to a file, whereas the second can be used to save the state to an instance of the ofstream class. There are likewise two corresponding ways in which the state can be restored.

The print method simply prints to an ostream the current state of the object.

=== Variance

This class is derived from Mean, and in addition to providing the above mentioned functionality also provides the following:

----
class Variance : public Mean
{
public:
    Variance ();
    virtual ~Variance ();
     
    virtual void setValue (double);
    virtual void operator+= (double);

    virtual void reset ();

    double variance () const;
    double stdDev () const;

    double confidence (double);

    virtual ostream& print (ostream&) const;

    virtual Boolean saveState (const char*) const;
    virtual Boolean saveState (ofstream&) const;
    
    virtual Boolean restoreState (const char*);
    virtual Boolean restoreState (ifstream&);
}
----

variance() returns the variance of the samples:

image::images/maths3.jpg[]

stdDev() returns the standard deviation of the samples, which is the square root of the variance.

=== TimeVariance

The TimeVariance class makes it possible to determine how long, in terms of simulation time, specific values were maintained. In effect, values are weighted according to the length of time that they were held, whereas with the Variance class only the specific values are taken into account.

----
class TimeVariance : public Variance
{
public:
    TimeVariance ();
    ~TimeVariance ();

    virtual void reset ();

    virtual void setValue (double);
    virtual void operator+= (double);

    double timeAverage () const;

    virtual Boolean saveState (const char*) const;
    virtual Boolean saveState (ofstream&) const;
    
    virtual Boolean restoreState (const char*);
    virtual Boolean restoreState (ifstream&);
}
----

Whenever a value is supplied to an instance of the TimeVariance class the simulation time at which it occurred is also noted. If a value changes, or the timeAverage() method is invoked, then the time it has been maintained for is calculated and the statistical data is updated.

=== Histograms

Mean, Variance, and TimeVariance provide a snapshot of values in the simulation. However, histograms can yield better information about how a range of values change over the course of a simulation run. This information can be viewed in a number of ways, but typically it is plotted in graphical form.

A histogram typically maintains a slot for each value, or range of values, given to it. These slots are termed _buckets_, and the way in which these buckets are maintained and manipulated gives rise to a variety of different histogram implementations. The following sections detail this variety of different histogram classes.

==== PrecisionHistogram

The PrecisionHistogram class represents the core histogram class from which all others are derived. This class keeps an exact tally of all values given to it, i.e., a bucket is created for each value. Although buckets are only created when requires, over the course of a simulation this can still utilise a large amount of resources, and so other, less precise, histogram classes are provided.

----
class PrecisionHistogram : public Variance
{
public:
    PrecisionHistogram ();
    virtual ~PrecisionHistogram ();
    
    virtual void setValue (double);
    virtual void operator+= (double);

    virtual void reset ();

    long numberOfBuckets () const;

    /*
     * There are two ways of getting the number of entries in a bucket:
     * (i) give the index number of the bucket, or
     * (ii) give the name of the bucket.
     * If the bucket is not present then FALSE is returned.
     */

    virtual Boolean sizeByIndex (long index, double& size);
    virtual Boolean sizeByName  (double name, double& size);

    virtual Boolean bucketName (long index, double& name);
    
    virtual ostream& print (ostream&) const;

    virtual Boolean saveState (const char*) const;
    virtual Boolean saveState (ofstream&) const;
    
    virtual Boolean restoreState (const char*);
    virtual Boolean restoreState (ifstream&);
}
----

As with the Variance class from which it is derived, and whose methods are obviously available, values can be supplied to the histogram through the setValue(double) method.

The number of buckets maintained by the histogram can be obtained from the numberOfBuckets() method. Each bucket is uniquely named by the values it contains, and can also be accessed by its index in the entire list of buckets.

There are therefore two ways of getting the number of entries in a bucket:

- by the index number of the bucket: sizeByIndex(long index, double& size).

- by the unique name of the bucket: sizeByName(double name, double& size).

If the bucket does not exist then FALSE is returned.

It is possible to output the contents of the histogram to standard output using the print() method.

==== Histogram

The problem with the PrecisionHistogram class is that it can use up a lot of system resources, especially over the course of a long simulation. Histogram attempts to alleviate this by presenting a histogram which is less accurate, but consumes less resources. Instead of maintaining a bucket for each individual value, it keeps a fixed number of buckets. Initially each bucket will store separate values as in the PrecisionHistogram, but when the number of required buckets would exceed the specified maximum number it merges pairs of buckets, thus reducing their total. The policy used when merging buckets it set on a per instance basis when created. Current policies are:

- ACCUMULATE: create a new bucket with the same name as the largest of the two buckets, and it has the sum of the two old bucket entries as its entry number.

- MEAN: create a new bucket with the name as the mean of the two old buckets, and it has the sum of the two old bucket entries as its entry number. 

- MAX: create a new bucket with the name as the largest of the two buckets, and it has the same number of entries. 
- MIN: create a new bucket with the name as the smallest of the two old buckets, and it has the same number of entries. 

----
class Histogram : public PrecisionHistogram
{
public:
    enum MergeChoice { ACCUMULATE, MEAN, MAX, MIN };
	
    Histogram (long, MergeChoice = MEAN);
    virtual ~Histogram ();
    
    virtual void setValue (double);
    virtual void operator+= (double);

    virtual ostream& print (ostream&) const;

    virtual Boolean saveState (const char*) const;
    virtual Boolean saveState (ofstream&) const;
    
    virtual Boolean restoreState (const char*);
    virtual Boolean restoreState (ifstream&);
}
----

When an instance of Histogram is created, the maximum number of allowed buckets must be specified. The merging algorithm can also be provided, with the default being the MEAN policy.

==== SimpleHistogram

As with the Histogram class above, SimpleHistogram keeps the number of assigned buckets to a minimum. However, it does this by pre-creating the buckets when it is created, i.e., the number of required buckets must be provided at the start. A width is the assigned for each bucket, and whenever a value if given to the histogram class it is placed into the bucket whose width it falls within.

----
class SimpleHistogram : public PrecisionHistogram
{
public:
    SimpleHistogram (double min, double max, long nbuckets);
    SimpleHistogram (double min, double max, double w);
    virtual ~SimpleHistogram ();
    
    virtual void setValue (double);
    virtual void operator+= (double);

    virtual void reset ();

    virtual Boolean sizeByName (double name, double& size);
    double  Width () const;

    virtual ostream& print (ostream&) const;

    virtual Boolean saveState (const char*) const;
    virtual Boolean saveState (ofstream&) const;
    
    virtual Boolean restoreState (const char*);
    virtual Boolean restoreState (ifstream&);
}
----

When the class is instantiated, the range of values it will receive must be provided. Then, either the width of each bucket or the actual number of buckets can be given. If the width is provided, then the histogram automatically calculates the number of buckets, otherwise it calculates the width for each bucket by equally dividing the range between each bucket.
The values of a bucket can be obtained from the sizeByName  method.

The width of each bucket is provided by the Width method.

==== Quantile

The Quantile class provides a means of obtaining the p-quantile of a distribution of values, i.e., the value below which p-percent of the distribution lies.

----
class Quantile : public PrecisionHistogram
{
public:
    Quantile (double = 0.95);
    virtual ~Quantile ();

    double operator() () const;
    double range () const;

    virtual ostream& print (ostream&) const;
}
----

The p-quantile probability range must be specified when the object is instantiated, and can be obtained via the range method.

The actual quantile value is provided by getValue method.

=== Example

In this example, similar to the one we saw earlier when discussing streams, takes a NormalStream and pushes the data obtained from it into a Quantile instance (also a PrecisionHistogram, as seen above).

----
NormalStream str(100.0, 2.0);
Quantile* hist = new Quantile();

for (int i = 0; i < 20; i++)
{
  hist->setValue(str());
}

cout << "NormalStream error: " << str.Error() << endl;

cout << *hist << endl;
----

If you were to execute this code then the output would be similar to the following:

----
NormalStream error: -0.2802
Quantile precentage : 0.95
Value below which percentage occurs 103.855
Bucket : < 97.5433, 1 >
Bucket : < 97.8832, 1 >
Bucket : < 98.2229, 1 >
Bucket : < 99.4531, 1 >
Bucket : < 99.5094, 1 >
Bucket : < 99.5275, 1 >
Bucket : < 99.8352, 1 >
Bucket : < 99.8953, 1 >
Bucket : < 100.459, 1 >
Bucket : < 100.512, 1 >
Bucket : < 100.612, 1 >
Bucket : < 100.77, 1 >
Bucket : < 100.773, 1 >
Bucket : < 101.173, 1 >
Bucket : < 101.658, 1 >
Bucket : < 101.916, 1 >
Bucket : < 102.539, 1 >
Bucket : < 102.88, 1 >
Bucket : < 103.855, 1 >
Bucket : < 105.432, 1 >

Variance          : 3.84068
Standard Deviation: 1.95977
Number of samples : 20
Minimum           : 1.17549e-38
Maximum           : 3.40282e+38
Sum               : 2014.45
Mean              : 100.722
----

Because Quantile is also a PrecisionHistogram, every unique number is assigned a unique bucket instance.

== References

[1] link:http://dl.acm.org/citation.cfm?id=1096934[G. M. Birtwistle, O-J. Dahl, B. Myhrhaug, K. Nygaard, “Simula Begin”, Academic Press, 1973].

[2] link:https://books.google.co.uk/books?id=4cCqCAAAQBAJ&pg=PA185&lpg=PA185&dq=O-J.+Dahl,+B.+Myhrhaug,+K.+Nygaard,+“SIMULA+Common+Base+Language”,+Norwegian+Computing+Centre&source=bl&ots=ZY5oBb1Hcy&sig=UurKDDPwtl_AMg6CgZcZ5Yyk8Ew&hl=en&sa=X&ved=0ahUKEwiygoLsiofKAhWDShQKHbtgDLkQ6AEIIjAA#v=onepage&q=O-J.%20Dahl%2C%20B.%20Myhrhaug%2C%20K.%20Nygaard%2C%20“SIMULA%20Common%20Base%20Language”%2C%20Norwegian%20Computing%20Centre&f=false[O-J. Dahl, B. Myhrhaug, K. Nygaard, “SIMULA Common Base Language”, Norwegian Computing Centre].

[3] link:http://www.amazon.com/The-Computer-Programming-Volume-Seminumerical/dp/0201038226[Knuth Vol2, “Seminumerical Algorithms”, Addison-Wesley, 1969, p. 117].

[4] link:http://algs4.cs.princeton.edu/home/[R. Sedgewick, “Algorithms”, Addison-Wesley, Reading MA, 1983, pp. 36-38].

[5] link:http://www.cs.ncl.ac.uk/publications/inproceedings/papers/630.pdf[D. L. McCue and M. C. Little, “Computing Replica Placement in Distributed Systems”, Proceedings of the 2 IEEE Workshop on the Management of Replicated Data, November 1992, pp. 58-61].

[6] link:https://books.google.co.uk/books?id=CF04AAAAIAAJ&pg=PR4&lpg=PR4&dq=I.+Mitrani,+“Simulation+Techniques+for+Discrete+Event+Systems”,+Cambridge+University+Press&source=bl&ots=zw-1g5mS30&sig=GxA8y1Moew5QYY3tYR6Hh19ifLw&hl=en&sa=X&ved=0ahUKEwjM0dCIiYfKAhVFwBQKHYogAcAQ6AEINDAD#v=onepage&q=I.%20Mitrani%2C%20“Simulation%20Techniques%20for%20Discrete%20Event%20Systems”%2C%20Cambridge%20University%20Press&f=false[I. Mitrani, “Simulation Techniques for Discrete Event Systems”, Cambridge University Press, Cambridge, 1982].

[7] link:http://www.cs.newcastle.ac.uk/publications/inproceedings/papers/29.pdf[M. C. Little and D. L. McCue, “The Replica Management System: a Scheme for Flexible and Dynamic Replication”, Proceedings of the 2 International Workshop on Configurable Distributed Systems, March 1994, pp. 46-57].

[8] link:https://www.usenix.org/legacy/publications/compsystems/1995/sum_parrington.pdf[G. D. Parrington et al, “The Design and Implementation of Arjuna”, Broadcast Project Technical Report, October 1994].
